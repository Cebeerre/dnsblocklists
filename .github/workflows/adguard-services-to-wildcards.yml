name: Build AdGuard services -> wildcard lists

on:
  schedule:
    - cron: "20 3 * * 1"   # weekly: Mon 03:20 UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SRC_INDEX: https://api.github.com/repos/AdguardTeam/HostlistsRegistry/contents/services?ref=main
      HOMEPAGE: https://github.com/${{ github.repository }}
      LICENSE_URL: https://github.com/${{ github.repository }}/blob/main/LICENSE
      ORIG_SOURCE: https://github.com/AdguardTeam/HostlistsRegistry/tree/main
    steps:
      - uses: actions/checkout@v4

      - name: Install jq and yq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          curl -fsSL https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 \
            -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Fetch index and build per-service wildcard lists (with skipped notes)
        run: |
          set -euo pipefail
          mkdir -p webservices

          TS="$(date -u +%Y%m%d%H%M)"
          curl -fsSL "$SRC_INDEX" > /tmp/services.json

          jq -r '.[] | select(.type=="file") | [.name, .download_url] | @tsv' /tmp/services.json \
          | while IFS=$'\t' read -r NAME DL; do
              echo "Processing: $NAME"
              TMP="/tmp/svc.yml"
              curl -fsSL "$DL" -o "$TMP"

              SID_RAW="$(yq -r '.id // .name // "unknown"' "$TMP")"
              SNAME="$(yq -r '.name // .id // "unknown"' "$TMP")"
              SID="$(echo "$SID_RAW" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/_/g')"

              yq -r '.rules // [] | .[]?' "$TMP" > /tmp/rules.txt || true

              DOMOUT="/tmp/${SID}.wild"
              SKIPOUT="/tmp/${SID}.skip"
              : > "$DOMOUT"
              : > "$SKIPOUT"

              awk -v DOMOUT="$DOMOUT" -v SKIPOUT="$SKIPOUT" '
                function tolower_str(s){ for(i=1;i<=length(s);i++){ c=substr(s,i,1); lc=tolower(c); o=o lc } out=o; o=""; return out }
                BEGIN{ FS="^" }
                {
                  gsub(/\r/,"")
                  line=$0
                }
                /^[[:space:]]*$/ { next }
                /^[[:space:]]*#/  { next }
                /^[[:space:]]*@@/ { next }         # skip exceptions

                # Case 1: Adblock network rule: ||domain^...
                /^[[:space:]]*\|\|[^|]/ {
                  split(line, parts, /\^/)
                  dom=parts[1]
                  sub(/^[[:space:]]*\|\|/, "", dom)
                  sub(/[,|$].*$/, "", dom)
                  # reject if contains any wildcard (unsupported for || rules)
                  if (dom ~ /\*/) {
                    print "# Skipped unsupported rule: " line >> SKIPOUT
                    next
                  }
                  # sanitize
                  sub(/^\.+/,"",dom); sub(/\.+$/,"",dom)
                  if (dom ~ /\./ && dom !~ /:\/\//) {
                    dom=tolower_str(dom)
                    print "*." dom >> DOMOUT
                  }
                  next
                }

                # Case 2: Direct domain or wildcard domain
                {
                  dom=line
                  # drop params (rare in direct lines)
                  sub(/[,|$].*$/, "", dom)
                  # normalize
                  sub(/^[[:space:]]+/,"",dom); sub(/[[:space:]]+$/,"",dom)
                  # If starts with "*.", check if there are more "*" later
                  if (dom ~ /^\*\./) {
                    rest=substr(dom,3)
                    if (rest ~ /\*/) {
                      print "# Skipped unsupported rule: " line >> SKIPOUT
                      next
                    }
                    sub(/\.+$/,"",dom)
                    dom=tolower_str(dom)
                    print dom >> DOMOUT
                    next
                  }
                  # If contains any "*" elsewhere -> unsupported
                  if (dom ~ /\*/) {
                    print "# Skipped unsupported rule: " line >> SKIPOUT
                    next
                  }
                  # Plain domain -> convert to *.domain
                  sub(/^\.+/,"",dom); sub(/\.+$/,"",dom)
                  if (dom ~ /\./ && dom !~ /:\/\//) {
                    dom=tolower_str(dom)
                    print "*." dom >> DOMOUT
                  }
                }
              ' /tmp/rules.txt

              sort -u -o "$DOMOUT" "$DOMOUT"

              OUT="webservices/${SID}_asterisk.txt"
              {
                echo "# Title: Blocklist for ${SNAME}"
                echo "# Description: Blocks ${SNAME} content (sourced from AdGuardTeam's HostlistsRegistry)"
                echo "# Homepage: ${HOMEPAGE}"
                echo "# License: ${LICENSE_URL}"
                echo "# Version: ${TS}"
                echo "# Original Source: ${ORIG_SOURCE}"
                echo "# Syntax: Domains Wildcard - Blocky (v0.23 or newer)"
                echo "#"
                if [ -s "$SKIPOUT" ]; then
                  echo "# Skipped unsupported rules:"
                  cat "$SKIPOUT"
                  echo "#"
                fi
                cat "$DOMOUT"
              } > "$OUT"

              echo "Wrote $OUT (lines: $(wc -l < "$OUT"))"
              rm -f "$DOMOUT" "$SKIPOUT" /tmp/rules.txt "$TMP"
            done

      - name: Commit & push if changed
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(services): refresh wildcard lists from AdGuard registry (skip unsupported)"
          file_pattern: "webservices/*.txt"
